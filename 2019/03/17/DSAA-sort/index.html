<!DOCTYPE html>
<html lang="zh-Hans">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>常用的八种排序算法和代码实现 | Arrietty&#39;s blog</title>
  
  <meta name="author" content="Arrietty" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="Java" />
  
  <meta property="og:type" content="article">
<meta property="og:title" content="常用的八种排序算法和代码实现">
<meta property="og:url" content="http://example.com/2019/03/17/DSAA-sort/index.html">
<meta property="og:site_name" content="Arrietty&#39;s blog">
<meta property="og:locale">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/17/AeRNf1.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/17/AeoD29.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/AmAYs1.gif">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/AmESSJ.gif">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/Am4noD.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/Am43QI.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/Amzm0e.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/Amz86f.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/Amzwhn.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/AmzsXT.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/AmzfhR.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/Amzg74.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/Amz7nO.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/AnS1UJ.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/AnitBV.gif">
<meta property="og:image" content="https://s2.ax1x.com/2019/03/18/AnKf1K.gif">
<meta property="article:published_time" content="2019-03-17T09:13:55.000Z">
<meta property="article:modified_time" content="2024-10-31T06:55:27.199Z">
<meta property="article:author" content="Arrietty">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/03/17/AeRNf1.png">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 7.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">Arrietty&#39;s blog</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>Arrietty&#39;s blog</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/03/17/DSAA-sort/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">常用的八种排序算法和代码实现</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2019-03-17T09:13:55.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2019-03-17</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">Arrietty</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~11.21K
                        
                        字
                    </li>
                
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1730357727199"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
            <hr />
            <div itemprop="articleBody"><p><img src="https://s2.ax1x.com/2019/03/17/AeRNf1.png"></p>
<span id="more"></span>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>我们经常会到这样一类排序问题：把新的数据插入到已经排好的数据列中。将第一个数和第二个数排序，然后构成一个有序序列将第三个数插入进去，构成一个新的有序序列。对第四个数、第五个数……直到最后一个数，重复第二步。</p>
<p>直接插入排序（Straight Insertion Sorting）的基本思想：在要排序的一组数中，假设前面(n-1) [n&gt;&#x3D;2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void insertSort(int[] li)</span><br><span class="line">&#123;</span><br><span class="line">	int len = li.length;</span><br><span class="line">	for (int i=1;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int insertNum = li[i];</span><br><span class="line">		int last = i - 1;</span><br><span class="line">		while last&gt;=0 &amp;&amp; insertNum&lt;li[last])</span><br><span class="line">		&#123;</span><br><span class="line">			li[last + 1] = li[last];</span><br><span class="line">			last--;</span><br><span class="line">		&#125;</span><br><span class="line">		li[last+1] = insertNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap&#x3D;length&#x2F;2，缩小增量继续以gap &#x3D; gap&#x2F;2的方式，这种增量选择我们可以用一个序列来表示，{n&#x2F;2,(n&#x2F;2)&#x2F;2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h3 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示"></a>过程演示</h3><p><img src="https://s2.ax1x.com/2019/03/17/AeoD29.png"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void shellSort(int[] li)</span><br><span class="line">&#123;</span><br><span class="line">	int len = li.length;</span><br><span class="line">	int gap = len/2;</span><br><span class="line">	while (gap&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i=gap;i&lt;len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			int insertNum = li[i];</span><br><span class="line">			int last = i - gap;</span><br><span class="line">			while (last&gt;=0 &amp;&amp; li[last]&gt;insertNum)</span><br><span class="line">			&#123;</span><br><span class="line">				li[last+gap] = li[last];</span><br><span class="line">				last -= gap;</span><br><span class="line">			&#125;</span><br><span class="line">			li[last+gap] = insertNum;</span><br><span class="line">		&#125;</span><br><span class="line">		gap /= 2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大(或小)的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] li)</span><br><span class="line">&#123;</span><br><span class="line">	int len = li.length;</span><br><span class="line">	for (int i=0;i&lt;len-1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j=0;j&lt;len-1-i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (li[j]&gt;li[j+1])</span><br><span class="line">			&#123;</span><br><span class="line">				int temp = li[j];</span><br><span class="line">				li[j] = li[j+1];</span><br><span class="line">				li[j+1] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void selectSort(int[] li)</span><br><span class="line">&#123;</span><br><span class="line">	int len = li.length;</span><br><span class="line">	for (int i=0;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int minIndex = i;</span><br><span class="line">		for (int j=i+1;j&lt;len;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (li[j]&lt;li[minIndex])</span><br><span class="line">			&#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int temp = li[i];</span><br><span class="line">		li[i] = li[minIndex];</span><br><span class="line">		li[minIndex] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<ul>
<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/03/18/AmAYs1.gif"></p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>public static int[] margeSort(int[] li)
&#123;
    int len = li.length;
    if (len&lt;2) return li;
    int mid = len/2;
    int[] left = Arrays.copyOfRange(li, 0, mid);
    int[] right = Arrays.copyOfRange(li, mid, len);
    return marge(margeSort(left), margeSort(right));
    
&#125;
public static int[] marge(int[] left, int[] right)
&#123;
    int[] result = new int[left.length + right.length];
    for (int index=0,i=0,j=0;index&lt;result.length;index++)
    &#123;
        if (i&gt;=left.length)
        &#123;
            result[index] = right[j++];
        &#125; else if(j&gt;=right.length)
        &#123;
            result[index] = left[i++];
        &#125; else if (left[i]&gt;right[j])
        &#123;
            result[index] = right[j++];
        &#125; else if (left[i]&lt;right[j])
        &#123;
            result[index] = left[i++];
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br><img src="https://s2.ax1x.com/2019/03/18/AmESSJ.gif"></p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int[] li, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	int len = li.length;</span><br><span class="line">	if (len&lt;0 || start&gt;=end) return;</span><br><span class="line">	int mid = (int) (start + Math.random()*(end - start + 1));</span><br><span class="line">	int sortIndex = start - 1;</span><br><span class="line">	swap(li, mid, end);</span><br><span class="line">	for (int i=start;i&lt;=end;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (li[i]&lt;=li[end])</span><br><span class="line">		&#123;</span><br><span class="line">			sortIndex++;</span><br><span class="line">			if (i&gt;sortIndex)</span><br><span class="line">			&#123;</span><br><span class="line">				swap(li,i,sortIndex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (start&lt;=sortIndex &amp;&amp; sortIndex&lt;=end)</span><br><span class="line">	&#123;</span><br><span class="line">		quickSort(li, start, sortIndex-1);</span><br><span class="line">		quickSort(li, sortIndex+1, end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] li, int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">	int temp = li[i];</span><br><span class="line">	li[i] = li[j];</span><br><span class="line">	li[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序比较难理解，下面描述转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6129630.html">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>　　堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：<br>　　<br><img src="https://s2.ax1x.com/2019/03/18/Am4noD.png"><br>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p>
<p><img src="https://s2.ax1x.com/2019/03/18/Am43QI.png"><br>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>
<p>**大顶堆：arr[i] &gt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &gt;&#x3D; arr[2i+2]  **</p>
<p>**小顶堆：arr[i] &lt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &lt;&#x3D; arr[2i+2]  **</p>
<p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p>
<h3 id="堆排序基本思想及步骤"><a href="#堆排序基本思想及步骤" class="headerlink" title="堆排序基本思想及步骤"></a>堆排序基本思想及步骤</h3><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong><br>1.假设给定无序序列结构如下<br><img src="https://s2.ax1x.com/2019/03/18/Amzm0e.png"><br>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length&#x2F;2-1&#x3D;5&#x2F;2-1&#x3D;1，也就是下面的6结点），从左至右，从下至上进行调整。<br><img src="https://s2.ax1x.com/2019/03/18/Amz86f.png"><br>3.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。<br><img src="https://s2.ax1x.com/2019/03/18/Amzwhn.png"><br>4.这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。<br><img src="https://s2.ax1x.com/2019/03/18/AmzsXT.png"><br>此时，我们就将一个无需序列构造成了一个大顶堆。<br><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong><br>a.将堆顶元素9和末尾元素4进行交换<br><img src="https://s2.ax1x.com/2019/03/18/AmzfhR.png"><br>b.重新调整结构，使其继续满足堆定义<br><img src="https://s2.ax1x.com/2019/03/18/Amzg74.png"><br>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.<br><img src="https://s2.ax1x.com/2019/03/18/Amz7nO.png"><br>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序<br><img src="https://s2.ax1x.com/2019/03/18/AnS1UJ.png"><br>再简单总结下堆排序的基本思路：<br><strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong><br><strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong><br><strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序</strong></p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static void heapSort(int[] li)</span><br><span class="line">&#123;</span><br><span class="line">	int len = li.length;</span><br><span class="line">	if (len&lt;=0) return;</span><br><span class="line">	for (int i=len/2-1;i&gt;=0;i--) adjustHeap(li,i,len);</span><br><span class="line">	for (int i=len-1;i&gt;0;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(li,0,i);</span><br><span class="line">		adjustHeap(li,0,i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">public static void adjustHeap(int[] li, int rootIndex, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int root = li[rootIndex];</span><br><span class="line">	for (int k=2*rootIndex+1;k&lt;len;k=2*k+1)</span><br><span class="line">	&#123;</span><br><span class="line">		if (k+1&lt;len &amp;&amp; li[k]&lt;li[k+1]) k++;</span><br><span class="line">		if (root&lt;li[k]) </span><br><span class="line">		&#123;</span><br><span class="line">			li[rootIndex] = li[k];</span><br><span class="line">			rootIndex = k;</span><br><span class="line">		&#125; else</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	li[rootIndex] = root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] li, int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">	int temp = li[i];</span><br><span class="line">	li[i] = li[j];</span><br><span class="line">	li[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://s2.ax1x.com/2019/03/18/AnitBV.gif"></p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void countSort(int[] li)</span><br><span class="line">&#123;</span><br><span class="line">	int len = li.length;</span><br><span class="line">	if (len==0) return;</span><br><span class="line">	int min = li[0], max = li[0];</span><br><span class="line">	for (int i=1;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (min&gt;li[i]) min = li[i];</span><br><span class="line">		if (max&lt;li[i]) max = li[i];</span><br><span class="line">	&#125;</span><br><span class="line">	int[] bucket = new int[max - min + 1];</span><br><span class="line">	Arrays.fill(bucket, 0);</span><br><span class="line">	for (int i=0;i&lt;len;i++) bucket[li[i] - min]++;</span><br><span class="line">	int index = 0;</span><br><span class="line">	for (int i=0;i&lt;bucket.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		while (bucket[i]!=0)</span><br><span class="line">		&#123;</span><br><span class="line">			li[index++] = i + min;</span><br><span class="line">			bucket[i]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
<h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize&#x3D;&#x3D;5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ul>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 桶排序</span><br><span class="line">     * </span><br><span class="line">     * @param array</span><br><span class="line">     * @param bucketSize</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) </span><br><span class="line">    &#123;</span><br><span class="line">        if (array == null || array.size() &lt; 2)</span><br><span class="line">            return array;</span><br><span class="line">        int max = array.get(0), min = array.get(0);</span><br><span class="line">        // 找到最大值最小值</span><br><span class="line">        for (int i = 0; i &lt; array.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            if (array.get(i) &gt; max)</span><br><span class="line">                max = array.get(i);</span><br><span class="line">            if (array.get(i) &lt; min)</span><br><span class="line">                min = array.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int bucketCount = (max - min) / bucketSize + 1;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);</span><br><span class="line">        ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; bucketCount; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; array.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; bucketCount; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            if (bucketSize == 1) </span><br><span class="line">            &#123; // 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误</span><br><span class="line">                for (int j = 0; j &lt; bucketArr.get(i).size(); j++)</span><br><span class="line">                    resultArr.add(bucketArr.get(i).get(j));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (bucketCount == 1)</span><br><span class="line">                    bucketSize--;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);</span><br><span class="line">                for (int j = 0; j &lt; temp.size(); j++)</span><br><span class="line">                    resultArr.add(temp.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultArr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<h3 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://s2.ax1x.com/2019/03/18/AnKf1K.gif"></p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 基数排序</span><br><span class="line">     * @param array</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int[] RadixSort(int[] array) </span><br><span class="line">    &#123;</span><br><span class="line">        if (array == null || array.length &lt; 2)</span><br><span class="line">            return array;</span><br><span class="line">        // 1.先算出最大数的位数；</span><br><span class="line">        int max = array[0];</span><br><span class="line">        for (int i = 1; i &lt; array.length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            max = Math.max(max, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int maxDigit = 0;</span><br><span class="line">        while (max != 0) </span><br><span class="line">        &#123;</span><br><span class="line">            max /= 10;</span><br><span class="line">            maxDigit++;</span><br><span class="line">        &#125;</span><br><span class="line">        int mod = 10, div = 1;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">            bucketList.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">        for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) </span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; array.length; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                int num = (array[j] % mod) / div;</span><br><span class="line">                bucketList.get(num).add(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            int index = 0;</span><br><span class="line">            for (int j = 0; j &lt; bucketList.size(); j++) </span><br><span class="line">            &#123;</span><br><span class="line">                for (int k = 0; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                    array[index++] = bucketList.get(j).get(k);</span><br><span class="line">                bucketList.get(j).clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong><br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guoyaohua/p/8600214.html">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></p>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2019/03/17/DSAA-sort/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2019/03/17/DSAA-sort/";
            const title         = "「常用的八种排序算法和代码实现」";
            const excerpt       = ``;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/Java/" rel="tag">Java</a>
                </div>
                <div class="pull-date">
                    <time datetime="2024-10-31T06:55:27.199Z" itemprop="dateModified">最后编辑：2024-10-31</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 写给自己的" href="/2019/03/17/hope/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" SpringBoot：开始你的第一个SpringBoot应用" href="/2019/03/19/DevlopingSpringBootApp/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                43
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                12
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                18
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/VsCode/">VsCode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/">分布式集群</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">图像处理</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/">建模语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3/">第三方接口</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">3</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Python-OpenCV/" style="font-size: 0.65em;">-Python -OpenCV</a> <a href="/tags/Alipay/" style="font-size: 0.65em;">Alipay</a> <a href="/tags/Cmake/" style="font-size: 0.6em;">Cmake</a> <a href="/tags/Docker/" style="font-size: 0.8em;">Docker</a> <a href="/tags/Github/" style="font-size: 0.6em;">Github</a> <a href="/tags/Hadoop/" style="font-size: 0.65em;">Hadoop</a> <a href="/tags/Hexo/" style="font-size: 0.7em;">Hexo</a> <a href="/tags/Java/" style="font-size: 0.8em;">Java</a> <a href="/tags/NexT/" style="font-size: 0.6em;">NexT</a> <a href="/tags/Node-js/" style="font-size: 0.6em;">Node.js</a> <a href="/tags/OpenCV/" style="font-size: 0.7em;">OpenCV</a> <a href="/tags/Python/" style="font-size: 0.75em;">Python</a> <a href="/tags/SpringBoot/" style="font-size: 0.7em;">SpringBoot</a> <a href="/tags/SpringSourceCode/" style="font-size: 0.6em;">SpringSourceCode</a> <a href="/tags/Themes/" style="font-size: 0.6em;">Themes</a> <a href="/tags/UML/" style="font-size: 0.6em;">UML</a> <a href="/tags/object-Object/" style="font-size: 0.6em;">[object Object]</a> <a href="/tags/%E9%B8%A1%E6%B1%A4/" style="font-size: 0.6em;">鸡汤</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2024/11/01/About-Configure-Cmake-with-VsCode/"><i class="fa  fa-book"></i> 基于Cmake的VsCode下的C/C++环境搭建日志</a>
            
          
        
          
          
            <a class="list-group-item" href="/2020/02/01/PriorityQueueAndHeap/"><i class="fa  fa-book"></i> 优先队列与堆</a>
            
          
        
          
          
            <a class="list-group-item" href="/2019/11/10/Algorithm-TreeAndBinaryTree/"><i class="fa  fa-book"></i> 树和二叉树</a>
            
          
        
          
          
            <a class="list-group-item" href="/2019/11/06/OpenCV-CoreOperation/"><i class="fa  fa-book"></i> OpenCV-核心操作</a>
            
          
        
          
          
            <a class="list-group-item" href="/2019/11/05/OpenCV-MousePaint/"><i class="fa  fa-book"></i> OpenCV-鼠标作画和滑块</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2024 Arrietty's blog 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Arrietty.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>